# -*- coding: utf-8 -*-
"""Project 4 Done

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Or86MXknCOD7CwBQ7hrSuI8aKevNGKAJ

# Project 4: Semantic Parsing

This project will have you implement a neural semantic parser for the GeoQA dataset of [Krishnamurthy and Kollar, 2013](http://rtw.ml.cmu.edu/tacl2013_lsp/tacl2013-krishnamurthy-kollar.pdf), which consists of a database of simple geographic facts about 10 US states, questions and answers about the database, and annotated logical forms for the questions. Your final system will go from natural language questions to their answers, computed from the database, via logical forms that are executed on the database. 

First, you'll implement a method for executing logical forms on the database. Then, you'll implement some components of a constrained sequence-to-sequence model for producing logical forms from questions. You will train it using paired questions and logical forms. Then, you will train it from questions-answer pairs, by searching over latent logical forms.

Note: this dataset is small enough that we will be able to train on CPU; you don't need a GPU instance.

## Setup

The dependencies for this project include:
* `torch` for modeling and training
* `sexpdata` for loading logical forms from [S-expressions](https://en.wikipedia.org/wiki/S-expression)
* `geoqa`: support code for loading and preprocessing the GeoQA database, evaluating predicted answers, and support code, available at this [github repo](https://github.com/dpfried/geoqa-release) (although you can treat the code as a black box and not worry about the details).
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install --upgrade torch tqdm sexpdata
# # this provides the packages available here: https://github.com/dpfried/geoqa-release
# !wget https://github.com/dpfried/geoqa-release/archive/master.zip -O geoqa.zip
# !unzip geoqa.zip
# !rm geoqa.zip
# !mv geoqa-release-master/data.tgz .
# !mv geoqa-release-master/geoqa .
# !mv geoqa-release-master/vecs .
# !rm -r geoqa-release-master
# !tar xf data.tgz
# 
# # Standard library imports
# import math
# import random
# import pprint
# import pickle
# from typing import Union, List, Set, Tuple
# from collections import namedtuple
# 
# # Third party imports
# import editdistance
# import matplotlib.pyplot as plt
# import numpy as np
# import torch
# import time
# import torch.nn as nn
# import tqdm.notebook
# import sexpdata
# 
# from torch.nn.utils.rnn import pad_sequence
# from torch.utils.data import Dataset, DataLoader
# 
# # geoqa imports; we'll examine these shortly
# import geoqa
# import geoqa.geo
# import geoqa.utils
# 
# from geoqa.utils import Stack, Index, logical_form_to_str
# from geoqa.geo import STATES, World
# from geoqa.geo import CATS, RELS, ENTITY_ACTIONS_TO_ENTITIES
# from geoqa.geo import LAMBDA, EXISTS, AND, VARS, MAX_LITERALS
# from geoqa.dataset import GeoDataset
# from geoqa.evaluation import evaluate_predictions
# 
# BIG_NEG = -1e9

"""## Data

First, let's examine the dataset. GeoQA contains 10 databases, one for each of 10 states.
"""

STATES

DEV_STATES = ["va", "wv"]
TEST_STATES = ["fl", "ga"]
TRAIN_STATES = [env for env in STATES if env not in DEV_STATES + TEST_STATES]

"""A database consists of a set of entities, and a collection of facts about these entities. Facts are either categories, which are unary predicates on entities, or relations, which are binary predicates between entity pairs."""

# all possible categories that can be used across states
' '.join(CATS)

# all possible relations that can be used across states
' '.join(RELS)

"""Not all categories and relations will be used in a given database; but here are a representation of the entities, categories, and relations for one state. This dataset is quite small, and the state data below represents one of the larger databases."""

world = geoqa.geo.read_world("va")
world.print()

"""Each state has a set of question-answer pairs, with an associated logical form for each question."""

questions, answers, logical_forms = geoqa.geo.read_data("va")

instance_index = 10

questions[instance_index]

"""Each answer is a set of entities from the database:"""

answers[instance_index]

"""Logical forms are lambda calculus functions represented as tuples:"""

logical_forms[instance_index]

print(logical_form_to_str(logical_forms[instance_index]))

"""This dataset has fairly simple lambda calculus expressions, which always consist of a single function and a conjunction of predicates. Because of this, every logical form contains:
1. **Variables** (`$x, $y, $z,` and `$w`), which can take on entity values from the database.
2. **Predicates**, of which there are three types:
    - **categories** (e.g. `city`), which take 1 variable as an argument, and return true if the category is true in the database for the entity assigned to the variable.
    - **relations** (e.g. `in-rel`), which take 2 variable arguments, and return true if the relation is true in the database for the ordered pair of entities assigned to the variables.
    - **entity predicates** (e.g. `kb-virginia`), which takes 1 variable argument and return true if the proper entity (e.g. `virginia`) is assigned to the variable.
3. A **conjunction** (`and`) of multiple **literals** (e.g. `(city $w)` is a literal). A literal consists of a predicate with some number of variables as argument.
4. [optional] An **existential quantifier** (`exists`), which takes as arguments all but one of the variables used within the conjunction, and the conjunction. `exists` is used if and only if more than one variable is used inside the `and` expression.
5. A **lambda expression** (`lambda`), which takes as arguments a single variable and either a conjunction (if the conjunction contains no other variables, other than the lambda's argument) or an existential quantifier (if it does).

Note: an alternative, more compact logical form representation would use entities directly when applicable, e.g. `(lambda $w (and (city $w) (in-rel $w virginia)))`. This would make the implementation of the logical form executor (which you'll complete in the next section) a bit more complex, but it would likely reduce the difficulty of learning the logical forms' structure. If you're interested, see [Liang 2013](https://arxiv.org/abs/1309.4408) for one approach used in many recent systems which takes this even further to eliminate all variables and make existential quantification implicit, more closely paralleling natural language.

In general, semantic parsing systems must trade off between the complexity of the lexicon, the syntax/semantics interface, compactness of the logical form structure, and the difficulty of inference and learning.  For this dataset, we'll find that a neural model is able to adequately learn  to predict these relatively verbose logical forms directly from sentences, given some lexical and structural constraints.
"""

# obtain all predicates (categories, relations, and entity predicates) from the dataset
PREDICATES = set(CATS) | set(RELS) | set(ENTITY_ACTIONS_TO_ENTITIES.keys())

' '.join(sorted(PREDICATES))

"""## Logical Form Executor

All logical forms in this dataset are lambda functions, which take database entities and return truth values. Each logical form's denotation (corresponding to the answer to its question) is the set of entities in the database for which the lambda function is true.
"""

questions[instance_index]

logical_form_to_str(logical_forms[instance_index])

answers[instance_index]

"""To evaluate a logical form's denotation in a database, we'll run a simple unification algorithm to build a denotation up recursively from sub-trees in the logical form's tree. Each sub-tree in the logical form will be associated with a `VariableAssignments` object, which contains the set of all possible assignments of entities to variables within the sub-tree that would satisfy the logical form:"""

# VariableAssignments: a collection of possible assignments of entities to
#   variables that satisfy the logical form, as processed so far
VariableAssignments = namedtuple('VariableAssignments', [
  'variables',
  # variables: Set[str]: variables that are assigned
  'assignments'
  # assignments: List[Dict[str, str]]: a list of variable assignments.
  #   each variable assignment dictionary should map every variable in 
  #   `variables` to an entity
])

"""In the cell below, we've defined operations to produce satisfying assignments for each of the three literal types (which occur at the leaves of the tree):"""

def entity_op(entity_predicate: str, variable: str, world: World) -> VariableAssignments:
  entity_name = ENTITY_ACTIONS_TO_ENTITIES[entity_predicate]
  assert entity_name in world.entities
  return VariableAssignments({variable}, [{variable: entity_name}])

def category_op(category: str, variable: str, world: World) -> VariableAssignments:
  index = CATS.index(category)
  values = (world.categories[index] == 1).nonzero()[0]
  return VariableAssignments(
    {variable},
    [{variable: world.index_to_entities[value]}
     for value in values],
  )

def relation_op(relation: str, variable_1: str, variable_2: str, world: World) -> VariableAssignments:
  index = RELS.index(relation)
  val_1s, val_2s = (world.relations[index] == 1).nonzero()
  assignments = [
    {variable_1: world.index_to_entities[val_1], variable_2: world.index_to_entities[val_2]}
    for val_1, val_2 in zip(
      val_1s, val_2s
    )
  ]
  return VariableAssignments(
    {variable_1, variable_2},
    assignments
  )

"""These literal operations are demonstrated below:"""

world = geoqa.geo.read_world("wv")
val_1s, val_2s = (world.relations[0] == 1).nonzero()
world.print()

logical_form = geoqa.utils.parse_tree('(lambda $w (exists $x (and (city $w) (in-rel $w $x) (kb-west_virginia $x))))')

entity_op('kb-west_virginia', '$x', world)

relation_op('in-rel', '$w', '$x', world)

category_op('city', '$w', world)

"""In the cell below, we've defined an `execute` function which will return the entity set denotation for a logical form by recursively traversing the logical form's tree and combining variable assignments from the leaves upward, using _sub-tree operations_.  The root node of the tree, the `lambda` node, has a `lambda_op` sub-tree operation which takes a `VariableAssignments` containing possible satisfying assignments, and returns the set of entities that the lambda variable takes on.

All other sub-tree operations take `VariableAssignments` returned by their children, and return a `VariableAssignments` giving the assignments that satisfy the sub-tree.

Some of the sub-tree operations (`entity_op`, `category_op`, `relation_op`) for literals were defined above; you'll define the others (`lambda_op`, `exists_op`, `and_op`) in the cells afterward.
"""

def execute(logical_form: Tuple, world: World):
  # recursively process the tree from the leaves upward. Each subtree should return:
  #   lambda nodes: a `set` of entities that satisfy the logical form
  #   all other node types: a VariableAssignments that contains possible assignments
  #       of entities to variables that would satisfy the subtree
  assert isinstance(logical_form, tuple)
  predicate = logical_form[0]
  if predicate in ENTITY_ACTIONS_TO_ENTITIES:
    var = logical_form[1]
    return entity_op(predicate, var, world)
  elif predicate in CATS:
    category = predicate
    var = logical_form[1]
    return category_op(category, var, world)
  elif predicate in RELS:
    rel = predicate
    var_1, var_2 = logical_form[1:]
    return relation_op(rel, var_1, var_2, world)
  elif predicate == LAMBDA:
    var = logical_form[1]
    var_assignments = execute(logical_form[2], world)
    return lambda_op(var, var_assignments)
  elif predicate == EXISTS:
    vars = logical_form[1:-1]
    var_assignments = execute(logical_form[-1], world)
    return exists_op(vars, var_assignments)
  elif predicate == AND:
    return and_op([
      execute(sub_lf, world)
      for sub_lf in logical_form[1:]
    ])
  else:
    raise NotImplementedError("invalid predicate {}\n{}".format(predicate, logical_form))

# helper function to use when testing results from the sub-tree operations
def are_equal(va1: VariableAssignments, va2: VariableAssignments) -> bool:
  def canonicalize(assignments):
    # compare sets of assignments, since ordering (and duplication) of assignments within the list does not affect meaning
    # convert each assignment dict to a string in json format since dictionaries are unhashable
    import json
    return set(json.dumps(d) for d in assignments)
  return va1.variables == va2.variables and canonicalize(va1.assignments) == canonicalize(va2.assignments)

"""Complete the `lambda_op`, `exists_op`, and `and_op` sub-tree operations in the cells below. Each operation has a test cell after it with sample inputs and outputs."""

def lambda_op(lambda_variable: str, variable_assignments: VariableAssignments) -> Set[str]:
  # return the entities that variable takes on in variable_assignments
  """YOUR CODE HERE"""
  
  ret = set()
  for dct in variable_assignments.assignments: ret.add(dct[lambda_variable])
  
  return ret

assert lambda_op('$y', VariableAssignments(
    {'$x', '$y'}, 
    [{'$x': 'virginia', '$y': 'richmond'}, {'$x': 'virginia', '$y': 'charleston'}]
  )) == {'richmond', 'charleston'}

def exists_op(existentially_quantified_vars: List[str], child_assignments: VariableAssignments) -> VariableAssignments:
  # remove the existentially-quantified variables from the assignments in variable_assignments
  """YOUR CODE HERE"""

  var_set = set(existentially_quantified_vars)
  new_vars = {v for v in child_assignments.variables if v not in var_set}
  # Equivalently, new_vars = child_assignments.variables.difference(var_set)
  #               new_vars = set.difference(child_assignments.variables, var_set)

  new_assignments = [{k : dct[k] for k in dct if k not in var_set}
                     for dct in child_assignments.assignments
                    ]
  new_asgmts = []
  for asgmt in new_assignments: new_asgmts.append(asgmt) if asgmt not in new_asgmts else None

  return VariableAssignments(new_vars, new_asgmts)

exists_test_1 = exists_op(['$x'], VariableAssignments(
    {'$x', '$y'}, [{'$x': 'virginia', '$y': 'richmond'}, {'$x': 'virginia', '$y': 'charleston'}]
  ))
assert are_equal(exists_test_1, VariableAssignments(
    {'$y'}, [{'$y': 'richmond'}, {'$y': 'charleston'}]
)), exists_test_1
                                             
exists_test_2 = exists_op(['$y'], VariableAssignments(
    {'$x', '$y'}, [{'$x': 'virginia', '$y': 'richmond'}, {'$x': 'virginia', '$y': 'charleston'}]
  ))
assert are_equal(exists_test_2, VariableAssignments(
    {'$x'},
    [{'$x': 'virginia'}]
)), exists_test_2

def and_op(children_assignments: List[VariableAssignments]) -> VariableAssignments:
  # join the assignments in children_assignments, to return possible assignments that satisfy all children
  """YOUR CODE HERE"""

  all_var_sets = [var_asgmts.variables for var_asgmts in children_assignments]
  variables = set.union(*all_var_sets)

  n = len(children_assignments)
  asgmt_lens = [len(var_asgmts.assignments) for var_asgmts in children_assignments]
  assignments = []

  if any([e == 0 for e in asgmt_lens]):
    return VariableAssignments(variables, assignments)

  asgmt_pointers = [0 for _ in range(n)]

  while asgmt_pointers[0] < asgmt_lens[0]:
    possible_assignment = {}
    conflict_flag = False

    for i in range(n):
      asgmt = children_assignments[i].assignments[ asgmt_pointers[i] ]

      for key in asgmt:
        if key in possible_assignment and possible_assignment[key] != asgmt[key]:
          conflict_flag = True
          break

      if conflict_flag:
        break
      else:
        possible_assignment.update(asgmt)

    asgmt_pointers[i] += 1
    for j in range(i):
      if asgmt_pointers[i - j] == asgmt_lens[i - j]:
        asgmt_pointers[i - j] = 0
        asgmt_pointers[i - j - 1] += 1
      else:
        break 

    if not conflict_flag and len(possible_assignment):
      assignments.append(possible_assignment)

  return VariableAssignments(variables, assignments)

and_test = and_op([
  VariableAssignments({'$x', '$y'}, [{'$x': 'x1', '$y': 'y1'}, {'$x': 'x2', '$y': 'y2'}]),
  VariableAssignments({'$z', '$y'}, [{'$z': 'z2', '$y': 'y2'}, {'$z': 'x3', '$y': 'y3'}]),                 
])
assert are_equal(
  and_test,
  VariableAssignments(variables={'$x', '$y', '$z'}, assignments=[{'$x': 'x2', '$y': 'y2', '$z': 'z2'}])
), and_test

"""With correct sub-tree operation definitions, the following test cell should run without errors. It checks that the entity set denotations returned by the `execute` function match the answers in the database."""

for state in STATES:
  world = geoqa.geo.read_world(state)
  for question, answer, logical_form in zip(*geoqa.geo.read_data(state)):
    if logical_form is None:
      continue
    true_denotation = world.get_denotation_from_answer(answer)
    executed_denotation = execute(logical_form, world)
    if true_denotation != executed_denotation:
      print("execution failure!")
      print("question: {}".format(question))
      print("state: {}".format(world))
      print("logical form: {}".format(logical_form))
      print("true denotation: {}".format(true_denotation))
      print("executed denotation: {}".format(executed_denotation))
      raise ValueError()

"""## Parser

Now that we have a method to execute logical forms on the database, we'll spend the rest of this assignment constructing parsers to produce logical forms from questions. 

Our question-to-logical-form parser will be a neural sequence-to-sequence model that will encode the question and decode a sequence of actions to construct a logical form. We will use _constrained decoding_ to prevent the model from constructing invalid logical forms, enforcing structural constraints rather than relying on the model to learn them.

To construct this parser, we first need to define a transition system: a set of actions that build up a logical form incrementally, and the effects each action has on a partially constructed logical form. This transition system will constrain the available actions that can be taken by the sequence-to-sequence model at any point in time to guarantee valid logical forms.

### Transition system

We'll construct logical forms using a depth-first, left-to-right traversal of the logical form's tree structure, with actions in a post-fix notation (so a predicate comes after the arguments it takes), and a final `DONE` action after the logical form is constructed. For example, the logical form

`(lambda $x (exists $w (and (state $w) (city $x) (in-rel $x $w))))`

will be constructed in the traversal order:

`$w state $x city $x $w in-rel and $w exists $x lambda DONE`

We will basically have one action for each of the items in the order above, with one change to simplify what our model needs to learn. In this dataset, which always combines literals with a single `and`, each logical form has exactly one variable as an argument to the lambda expression, and existentially quantifies all other variables. Because of this, the actions between `and` and the `lambda` are determined by the lambda's variable argument (`$x`) and the other variables that have previously been introduced (all variables other than the lambda variable must be existentially quantified). This allows us to replace these actions with a single action, `complete_lambda_$x`. For the example above:

`$w state $x city $x $w in-rel complete_lambda_$x DONE`

If the question had been about the variable `$w`, we would instead use `complete_lambda_$w` so that `$w` was used with `lambda` and everything else was existentially quantified.

Note that other datasets with more complex logical forms would need to generate conjunctions and quantifiers individually, rather than using these simplifying `complete_lambda_` actions.

### Actions

We'll now define the actions used by our transition system. Variables and predicates will be taken directly from the items in the logical forms. We'll define new actions for `COMPLETE_LAMBDA_*` and `DONE`:
"""

# mapping from complete lambda action to the lambda's variable
COMPLETE_LAMBDA_ACTIONS_TO_VARS = {'COMPLETE_LAMBDA_{}'.format(var): var for var in VARS}
# and reverse
VARS_TO_COMPLETE_LAMBDA_ACTIONS = {v: k for k, v in COMPLETE_LAMBDA_ACTIONS_TO_VARS.items()}

DONE_ACTION = 'DONE'

"""Actions will be divided into three types, which will be produced differently by our model."""

STRUCTURAL_ACTIONS = VARS + sorted(COMPLETE_LAMBDA_ACTIONS_TO_VARS.keys()) + [DONE_ACTION]
CROSS_DATABASE_PREDICATE_ACTIONS = CATS + RELS
DATABASE_SPECIFIC_PREDICATE_ACTIONS = list(ENTITY_ACTIONS_TO_ENTITIES.keys())

ACTIONS = set(STRUCTURAL_ACTIONS) | set(CROSS_DATABASE_PREDICATE_ACTIONS) | set(ENTITY_ACTIONS_TO_ENTITIES.keys())

print(STRUCTURAL_ACTIONS)

print(CROSS_DATABASE_PREDICATE_ACTIONS[:5])

print(DATABASE_SPECIFIC_PREDICATE_ACTIONS[:5])

"""### From actions to logical forms

This `ParseConstraints` class will contain possible options to constrain the logical form being constructed, which will become important later when we begin searching over logical forms.
"""

ParseConstraints = namedtuple('ParseConstraints', [
  'possible_predicates',
  # set[str]: set of predicates to allow in this logical form
  'max_vars',
  # int: maximum number of distinct variables to allow in the logical form
  #   the maximum number in the dataset is 4 (len(VARS))
  'no_repeated_literals',
  # bool: if True, don't allow the same literal to appear more than once
  #   e.g. (and (state $x) (state $x)) is disallowed, but (and (state $x) (state $y)) is ok
  'max_literals'
  # int: disallow more than this many literals
  #   e.g. if max_literals == 1, (and (state $x) (city $y)) is disallowed
  #   the maximum number in the dataset is 7 (MAX_LITERALS)
])

"""To build up a logical form via a sequence of actions, we define a `ParserState` class several blocks below. This will represent the logical form as constructed so far and compute valid actions that can be taken to continue constructing it. The `_ParserState` class here defines the actual state variables, then you will fill in the methods in `ParserState` (without the underscore)."""

_ParserState = namedtuple('_ParserState', [
  'variable_argument_stack',
  # Stack[str]: variables to be put into the current literal
  'completed_literal_stack',
  # Stack[tuple]: all literals produced so far
  'has_lambda',
  # bool: whether the lambda has been generated
  'lambda_var',
  # str or None: the lambda's variable argument, if lambda has been generated; or None otherwise
  'is_complete',
  # bool: whether the DONE action has been generated
  'all_vars_introduced',
  # Stack[str]: variables should be appened to this each time they are used
  'past_actions',
  # Stack[str]: all previous actions taken
  'parse_constraints',
  # ParseConstraints: options to constrain the logical form being constructed
])

"""`variable_argument_stack` contains any variables that  will be put into the literal which is currently being constructed. This is reset to empty when a literal is completed (by a predicate action). All literals, as they are completed, are added to `completed_literal_stack`. This should not be emptied at any point, as it will be used to construct the final logical form.

For example, when generating the logical form 

`(lambda $x (exists $w (and (state $w) (city $x) (in-rel $x $w)))`

using the action sequence

`$w state $x city $x $w in-rel complete_lambda_$x DONE`,

the `ParserState` will look as follows after the first `$x` action:
```
ParserState(
  variable_argument_stack=['$x'],
  completed_literal_stack=[('state', '$w')],
  has_lambda=False,
  lambda_var=None,
  is_complete=False,
  all_vars_introduced=['$w', '$x'],
  past_actions=['$w', 'state', '$x'],
  parse_constraints=...
)
```
and as follows after the `DONE` action:
```
ParserState(
  variable_argument_stack=[],
  completed_literal_stack=[('state', '$w'), ('city', '$x'), ('in-rel', '$x', '$w')],
  has_lambda=True,
  lambda_var=$x,
  is_complete=True,
  all_vars_introduced=['$w', '$x', '$x', '$w'],
  past_actions=['$w', 'state', '$x', 'city', '$x', '$w', 'in-rel', 'COMPLETE_LAMBDA_$x', 'DONE'],
  parse_constraints=...
)
```

We'll now define a `ParserState` wrapper class with methods. Complete the `take_action` method in the `ParserState` class below.

Implementation tip: `ParserState` objects are immutable, and the `take_action` method should return a new `ParserState` object, rather than attempting to update the object (this will allow `ParserState` objects to be used in beam search). The [Stack](https://github.com/dpfried/geoqa-release/blob/master/geoqa/utils.py#L7) class used in `ParserState` for `variable_argument_stack`, `completed_literal_stack`, `all_vars_introduced`, and `past_actions` is an immutable data structure that is essentially like a list, but will allow sharing some memory across multiple `ParserState`s as search is performed, for efficiency and to prevent copying. See the cell below for a demonstration:
"""

# demonstration of the Stack class used in _ParserState
actions = Stack.empty().append('$w')
print(actions.tolist())
actions_plus_city = actions.append('city')
actions_plus_state = actions.append('state')
print(actions.tolist()) # hasn't changed
print(actions_plus_city.tolist()) # shares '$w' with actions
print(actions_plus_state.tolist()) # shares '$w' with actions
print(actions_plus_city.size) # 2

class ParserState(_ParserState):
  """
  Wrapper class to add methods and constants to _ParserState
  """
  PREDICATE_ARITIES = {}
  for cat in CATS:
    PREDICATE_ARITIES[cat] = 1
  for rel in RELS:
    PREDICATE_ARITIES[rel] = 2
  for entity in ENTITY_ACTIONS_TO_ENTITIES.keys():
    PREDICATE_ARITIES[entity] = 1

  MAX_ARITY = max(PREDICATE_ARITIES.values())

  @staticmethod
  def initial_state(parse_constraints):
    return ParserState(
      variable_argument_stack=Stack.empty(),
      completed_literal_stack=Stack.empty(),
      has_lambda=False,
      lambda_var=None,
      is_complete=False,
      all_vars_introduced=Stack.empty(),
      past_actions=Stack.empty(),
      parse_constraints=parse_constraints,
    )

  def take_action(self, action_symbol: str):
    assert action_symbol in ACTIONS, "invalid action {}".format(action_symbol)
    assert not self.is_complete

    assert action_symbol in self.valid_actions(), "trying to take {} but only valid actions are {}.\npast actions: {}".format(
      action_symbol, self.valid_actions(), ' '.join(self.actions()))

    # initialize all variables that might be updated
    past_actions = self.past_actions
    has_lambda = self.has_lambda
    is_complete = self.is_complete
    completed_literal_stack = self.completed_literal_stack
    variable_argument_stack = self.variable_argument_stack
    all_vars_introduced = self.all_vars_introduced
    lambda_var = self.lambda_var

    past_actions = past_actions.append(action_symbol)

    if action_symbol in PREDICATES:
      """YOUR CODE HERE"""

      var_args = variable_argument_stack.tolist()
      literal = tuple([action_symbol] + var_args)
      completed_literal_stack = completed_literal_stack.append(literal)
      variable_argument_stack = Stack.empty()

    elif action_symbol in VARS:
      """YOUR CODE HERE"""

      all_vars_introduced = all_vars_introduced.append(action_symbol)
      variable_argument_stack = variable_argument_stack.append(action_symbol)

    elif action_symbol in COMPLETE_LAMBDA_ACTIONS_TO_VARS.keys():
      """YOUR CODE HERE"""

      has_lambda = True
      lambda_var = COMPLETE_LAMBDA_ACTIONS_TO_VARS[action_symbol]

    elif action_symbol == DONE_ACTION:
      """YOUR CODE HERE"""

      is_complete = not is_complete

    else:
      raise ValueError("invalid action {}".format(action_symbol))

    return ParserState(
      variable_argument_stack=variable_argument_stack,
      completed_literal_stack=completed_literal_stack,
      has_lambda=has_lambda,
      lambda_var=lambda_var,
      is_complete=is_complete,
      all_vars_introduced=all_vars_introduced,
      past_actions=past_actions,
      parse_constraints=self.parse_constraints,
    )

  def variables_introduced(self) -> Set[str]:
    """
    :return: variables that have been used in the logical form, as constructed so far
    """
    variables = set(self.all_vars_introduced.tolist())
    assert variables == set(VARS[:len(
      variables)]), "variables should not be introduced out of the sequential order {}, but {} were used".format(VARS,
                                                                                                                 vars)
    return variables

  def variables_usable(self) -> Set[str]:
    """
    To reduce the set of possible logical forms, enforce that new variables are introduced in alphabetical order, e.g. $x cannot be used before $w has been used
    Usable variables include all previously used variables and the next in alphabetical order
    :return: set of possible next variables to use
    """
    num_vars_introduced = len(self.variables_introduced())
    return set(VARS[:min(self.parse_constraints.max_vars, num_vars_introduced + 1)])

  def to_logical_form(self) -> Tuple:
    """
    Convert a completed parser state to a logical form
    :return: logical form as a tuple
    """
    assert self.is_complete

    # list of tuples
    clause_literals = self.completed_literal_stack.tolist()

    assert len(clause_literals) > 0
    logical_form = (AND,) + tuple(clause_literals)

    assert self.lambda_var is not None
    vars_to_quantify = tuple(sorted(v for v in self.variables_introduced() if v != self.lambda_var))
    if len(vars_to_quantify) > 0:
      logical_form = (EXISTS,) + vars_to_quantify + (logical_form,)
    logical_form = (LAMBDA, self.lambda_var, logical_form)

    return logical_form

  @staticmethod
  def from_logical_form(logical_form: Tuple, parse_constraints: ParseConstraints=None):
    """
    :param logical_form:
    :param parse_constraints: used to check the logical form
    :return:
    """
    # depth-first post-fix traversal, where actions are node labels, except we
    # (1) collapse (lambda $LAMBDA_VAR (exists $VAR1 $VAR2 to COMPLETE_LAMBDA_$LAMBDA_VAR
    # (2) do not produce an action for the AND label
    # (3) add a DONE_ACTION action at the end (root)
    if parse_constraints is None:
      parse_constraints = ParseConstraints(
        possible_predicates=None, max_vars=len(VARS), no_repeated_literals=False,
        max_literals=MAX_LITERALS
      )

    def _traverse(node: Union[tuple, str], state: ParserState):
      if isinstance(node, tuple):
        label = node[0]
        if label == LAMBDA:
          lambda_var = node[1]
          assert lambda_var in VARS
          children = node[2:]
          assert children
        elif label == EXISTS:
          children = node[1:]
          while children[0] in VARS:
            children = children[1:]
          assert children
        else:
          children = node[1:]
      else:  # is a leaf; should be a variable
        label = node
        children = []
      for child in children:
        state = _traverse(child, state)
      if label == LAMBDA:
        state = state.take_action(VARS_TO_COMPLETE_LAMBDA_ACTIONS[lambda_var])
      elif label != AND and label != EXISTS:
        state = state.take_action(label)
      return state

    state = ParserState.initial_state(parse_constraints)
    state = _traverse(logical_form, state)
    state = state.take_action(DONE_ACTION)
    assert state.is_complete
    return state

  def actions(self) -> List[str]:
    return self.past_actions.tolist()

  def valid_actions(self) -> List[str]:
    # actions that can be taken if we've finished building the lambda expression
    if self.is_complete:
      return []
    if self.has_lambda:
      return [DONE_ACTION]

    # otherwise, deal with each possible action type in turn
    valid_actions = []

    # complete the lambda expression
    if self.variable_argument_stack.size == 0 and self.completed_literal_stack.size > 0:
      for var in self.variables_introduced():
        valid_actions.append(VARS_TO_COMPLETE_LAMBDA_ACTIONS[var])

    # introduce a predicate, with arguments from argument_stack
    if self.variable_argument_stack.size > 0:
      possible_predicates = self.parse_constraints.possible_predicates
      if possible_predicates is None:
        possible_predicates = CATS + RELS + list(ENTITY_ACTIONS_TO_ENTITIES.keys())
      possible_predicates = list(sorted(possible_predicates))

      for predicate in possible_predicates:
        if ParserState.PREDICATE_ARITIES[predicate] == self.variable_argument_stack.size:
          valid_actions.append(predicate)

    # add a variable to the argument stack
    if self.variable_argument_stack.size < ParserState.MAX_ARITY and (
        # only start a new literal if we're strictly less than the maximum
        (self.variable_argument_stack.size == 0 and self.completed_literal_stack.size < self.parse_constraints.max_literals) or
        # only continue an existing literal if we're no greater than the maximum
        (self.variable_argument_stack.size > 0 and self.completed_literal_stack.size <= self.parse_constraints.max_literals)
    ):
      valid_actions.extend(self.variables_usable())

    return valid_actions

  def __repr__(self):
    return """ParserState(
variable_argument_stack={},
completed_literal_stack={},
has_lambda={},
lambda_var={},
is_complete={},
all_vars_introduced={},
past_actions={},
parse_constraints={},
)""".format(*self)

"""With a correct implementation of `take_action`, the following three test cells should run without errors."""

permissive_parse_constraints = ParseConstraints(
    possible_predicates=PREDICATES, 
    max_vars=len(VARS),
    no_repeated_literals=False, 
    max_literals=MAX_LITERALS,
)

blank_parser_state = ParserState.initial_state(permissive_parse_constraints)
parser_state = blank_parser_state.take_action('$w')
assert parser_state.variable_argument_stack.tolist() == ['$w']
parser_state = parser_state.take_action('$x')
assert parser_state.variable_argument_stack.tolist() == ['$w', '$x']
parser_state = parser_state.take_action('in-rel')
assert parser_state.variable_argument_stack.tolist() == []
assert parser_state.completed_literal_stack.tolist() == [('in-rel', '$w', '$x')], parser_state.completed_literal_stack.tolist()
assert parser_state.actions() == ['$w', '$x', 'in-rel']

for state in STATES:
  world = geoqa.geo.read_world(state)
  for question, answer, logical_form in zip(*geoqa.geo.read_data(state)):
    if logical_form is None:
      continue
    parser_state = ParserState.from_logical_form(logical_form, permissive_parse_constraints)
    round_trip_logical_form = parser_state.to_logical_form()
    assert logical_form == round_trip_logical_form, "\n{} !=\n{}".format(logical_form, round_trip_logical_form)

"""## Preprocessing

Next we'll define a dataset class. Since this dataset is small, and to allow evaluating on databases with entities we didn't see in training, we'll use pre-trained embeddings to represent both words and predicates in the databases. We've downloaded and pre-filtered [fasttext](https://fasttext.cc/) word embeddings trained on English Wikipedia and news, and we'll use the first 50 dimensions to keep our models small.
"""

EMBEDDING_DIM = 50
word_to_embedding = geoqa.utils.get_word_vectors(
    'vecs/wiki-news-300d-1M-subword-filtered.vec', max_dim=EMBEDDING_DIM
)

word_to_embedding['virginia']

"""We've defined a [`GeoDataset`](https://github.com/dpfried/geoqa-release/blob/master/geoqa/dataset.py#L16) class for you in the support code to preprocess the data (don't worry about reading the code though; we'll demonstrate it below). This class tokenizes each question, and associated with each token a list of predicates that could possibly be used in the logical form, based on string matching predicate names against the word. To constrain the search space over possible logical forms, we will only allow predicates for a given question from the union of all its tokens' predicates. That we can do this at all is a somewhat unique feature of this dataset; more complex semantic parsing problems also require learning more of the lexicon as well."""

sample_dataset = GeoDataset(state_names=['wv', 'va'], word_to_embedding=word_to_embedding)

def print_instance(instance, print_tokens=False):
  for key in ['question', 'answer', 'logical_form', 'world', 'possible_predicates', 'denotation']:
    if key == 'logical_form':
      rep = logical_form_to_str(instance[key])
    else:
      rep = instance[key]
    print('{:<19}: {}'.format(key, rep))
  if print_tokens:
    print()
    print('{:<10}: {}'.format('word', 'predicates'))
    print('='*23)
    for word, predicates, embedded_predicates in zip(
      instance['words'], 
      instance['predicates_at_each_word_position'], 
      instance['embedded_predicates_at_each_word_position']
    ):
      print('{:<10}: {}'.format(word, ', '.join(predicates)))

sample_instance = sample_dataset[30]

print_instance(sample_instance, print_tokens=True)

"""## Model

In this section we'll define a neural sequence-to-sequence model that encodes a question and outputs the actions needed to produce its logical form.

We will use a `_ModelState` class to wrap a `ParserState` and also contain a model's hidden state (for the sequence-to-sequence decoder) and the log probabilities of the next possible actions that can be taken from the parser state.
"""

_ModelState = namedtuple('_ModelState', (
  'parser_state',
  # ParserState: the current parser state
  'hidden_state',
  # a tuple (h, c) of pytorch tensors
  'action_log_probs'
  # Dict[str, tensor]: a mapping from next possible actions (parser_state.valid_actions) to
  # a pytorch scalar giving the log probability of that action
))

"""The `ModelState` class will inherit from `_ModelState` and add a `take_action` method which creates a new `ModelState`, updated using a forward pass of the model and the `take_action` method of the `ParserState`.

Here's a DummyModel which always produces a uniform probability distribution over all available actions:
"""

class DummyModel(nn.Module):
  # model that produces scores of zero always; use to explore logical forms
  def __init__(self, max_vars=len(VARS), no_repeated_literals=False, max_literals=MAX_LITERALS):
    super(DummyModel, self).__init__()
    self.max_vars = max_vars
    self.max_literals = max_literals
    self.no_repeated_literals = no_repeated_literals

  def forward(self, actions_to_score):
    action_log_probs = {
      # a scalar tensor (dimension 0)
      action: torch.tensor(1.0/len(actions_to_score)).log()
      for action in actions_to_score
    }
    hidden_state = None
    return action_log_probs, hidden_state

  def initialize_model_state(self, instance):
    parse_constraints = ParseConstraints(
      possible_predicates=instance['possible_predicates'],
      max_vars=self.max_vars,
      no_repeated_literals=self.no_repeated_literals,
      max_literals=self.max_literals,
    )
    # define self as a variable so that we can reference it inside the DummyModelState class without using self;
    model = self

    class DummyModelState(_ModelState):
      @staticmethod
      def _create_from_parser_state(parser_state):
        possible_actions = parser_state.valid_actions()
        action_log_probs, hidden_state = model.forward(possible_actions)
        return DummyModelState(parser_state, hidden_state, action_log_probs)

      def take_action(self, action: str):
        new_parser_state = self.parser_state.take_action(action)
        return DummyModelState._create_from_parser_state(new_parser_state)

    parser_state = ParserState.initial_state(parse_constraints)
    return DummyModelState._create_from_parser_state(parser_state)

"""We can use this DummyModel to explore the space of possible (constrained) logical forms for a given instance."""

def greedy_search(model, instance):
  state = model.initialize_model_state(instance)
  log_probs = []
  # when we disallow repeated literals, we can get to parser states with no available actions
  # so we need to check to ensure there are scored items in `state.action_log_probs`
  while state.action_log_probs.items() and not state.parser_state.is_complete:
    action, log_prob = max(state.action_log_probs.items(), key=lambda tuple: tuple[1].item())
    log_probs.append(log_prob)
    state = state.take_action(action)
  return state, sum(log_probs)

print_instance(sample_instance, print_tokens=True)

model_state, total_log_prob = greedy_search(
    DummyModel(max_vars=4, no_repeated_literals=False),
    sample_instance
    )
print(logical_form_to_str(model_state.parser_state.to_logical_form()))
print(total_log_prob)

"""Now, we've defined an (unbatched) beam search for you in the two cells below. Only a small number of actions will be allowed to be taken at any point in time by our transition system, so we've chosen to use dictionaries to map actions to scores:"""

def k_best(score_dict, k):
  k = min(k, len(score_dict))
  if k == 0:
    return {}
  actions, logits = zip(*score_dict.items())
  logits = torch.stack(logits, dim=-1).flatten()
  chosen_scores, indices = logits.topk(k, dim=-1)
  indices = indices
  return {
    actions[index.item()]: score
    for score, index in zip(chosen_scores, indices)
  }

def beam_search(model, instance, beam_size):
  state = model.initialize_model_state(instance)
  completed = []
  # each beam item will be a tuple (state, cumulative log probs)
  beam = [(state, torch.tensor(0.0))]
  while beam and len(completed) < beam_size:
    successors = []
    for state, log_prob in beam:
      scored_successors = k_best(state.action_log_probs, beam_size)
      for action, action_log_prob in scored_successors.items():
        successor_log_prob = log_prob + action_log_prob
        successors.append((successor_log_prob, state, action))
    # when we disallow repeated literals, we can get to parser states with no available actions
    # so we need to check to see if there are successors available
    if not successors:
      break
    log_probs = torch.stack([log_prob for log_prob, _, _ in successors], dim=-1).flatten()
    if beam_size is None:
      indices = torch.arange(len(successors))
    else:
      _, indices = log_probs.topk(min(len(successors), beam_size), dim=-1)
    new_beam = []
    for ix in indices:
      log_prob, prev_state, action = successors[ix.item()]
      state = prev_state.take_action(action)
      if state.parser_state.is_complete:
        completed.append((state, log_prob))
      else:
        new_beam.append((state, log_prob))
    beam = new_beam

  completed = sorted(completed, key=lambda t: t[1].item(), reverse=True)
  completed = completed[:beam_size]
  return completed

def sample_search_model(model, beam_size):
  """
  A convenience method for printing out beam search outputs
  """
  for model_state, total_log_prob in beam_search(model, sample_instance, beam_size):
      # with the transition system we've defined,
      # it's possible to get into a parser state with no available actions
      # so we need to check to ensure the parser state is complete before
      # converting it to a logical form
    if model_state.parser_state.is_complete:
      logical_form = model_state.parser_state.to_logical_form()
      print("{:.2f} {}".format(total_log_prob.item(), logical_form_to_str(logical_form)))
    else:
      print("incomplete logical form")

print_instance(sample_instance)

sample_search_model(DummyModel(max_vars=1, no_repeated_literals=False), beam_size=20)

"""You may notice that some literals are repeated within a single logical form, e.g. `... (border-rel $w $w) (border-rel $w $w) ...` (due to randomness, you may not see this exact example in the candidates above). Since these identical literals occur inside a conjunction, they're logically redundant. Because of this, we can prevent duplicate literals to reduce the search space, without affecting the expressiveness of the logical forms.

Modify the `valid_actions` function below to prevent duplicate literals, if `self.parse_constraints.no_repeated_literals` is `True`. (We've copied this function from `ParserState.valid_actions`, and will monkey-patch `ParserState` with it, so that you don't have to scroll back and forth.)
"""

def valid_actions(self: ParserState) -> List[str]:
    # actions that can be taken if we've finished building the lambda expression
    if self.is_complete:
      return []
    if self.has_lambda:
      return [DONE_ACTION]

    # otherwise, deal with each possible action type in turn
    valid_actions = []

    # complete the lambda expression
    if self.variable_argument_stack.size == 0 and self.completed_literal_stack.size > 0:
      for var in self.variables_introduced():
        valid_actions.append(VARS_TO_COMPLETE_LAMBDA_ACTIONS[var])

    # introduce a predicate, with arguments from argument_stack
    if self.variable_argument_stack.size > 0:
      possible_predicates = self.parse_constraints.possible_predicates
      if possible_predicates is None:
        possible_predicates = CATS + RELS + list(ENTITY_ACTIONS_TO_ENTITIES.keys())
      possible_predicates = list(sorted(possible_predicates))

      for predicate in possible_predicates:
        if ParserState.PREDICATE_ARITIES[predicate] == self.variable_argument_stack.size:
          if self.parse_constraints.no_repeated_literals:
            # TODO: modify this method so that no repeated literals are allowed in the logical form
            """YOUR CODE HERE"""

            repeated = [predicate == literal[0] for literal in self.completed_literal_stack]
            if sum(repeated) > 0: continue

          valid_actions.append(predicate)

    # add a variable to the argument stack
    if self.variable_argument_stack.size < ParserState.MAX_ARITY and (
        # only start a new literal if we're strictly less than the maximum
        (self.variable_argument_stack.size == 0 and self.completed_literal_stack.size < self.parse_constraints.max_literals) or
        # only continue an existing literal if we're no greater than the maximum
        (self.variable_argument_stack.size > 0 and self.completed_literal_stack.size <= self.parse_constraints.max_literals)
    ):
      valid_actions.extend(self.variables_usable())

    return valid_actions

ParserState.valid_actions = valid_actions

"""With a correct implementation, you should now see that literals are not repeated:"""

sample_search_model(DummyModel(max_vars=1, no_repeated_literals=True), beam_size=20)

"""The test cell below, which checks to ensure that there are no repeated literals, should pass."""

for model_state, score in beam_search(DummyModel(max_vars=1, no_repeated_literals=True), sample_instance, 1000):
  completed_literals = model_state.parser_state.completed_literal_stack.tolist()
  # check for duplicate literals
  assert len(completed_literals) == len(set(completed_literals))

"""And the test from before of logical form -> parser state -> logical form (now using `no_repeated_literals=True`) should still pass:"""

no_repeats_parse_options = ParseConstraints(
    possible_predicates=PREDICATES, 
    max_vars=len(VARS), 
    no_repeated_literals=True, 
    max_literals=MAX_LITERALS
)
for logical_form in logical_forms:
  if logical_form is None:
    continue
  parser_state = ParserState.from_logical_form(logical_form, no_repeats_parse_options)
  round_trip_logical_form = parser_state.to_logical_form()
  assert logical_form == round_trip_logical_form, "{} != {}".format(logical_form, round_trip_logical_form)

"""We'll now evaluate this `DummyModel` as a very simple baseline, using [geoqa.evaluation.evaluate_predictions](https://github.com/dpfried/geoqa-release/blob/master/geoqa/evaluation.py), in the two cells below. You might be surprised at the accuracy; a few structural and lexical constraints can go a long way on this dataset, and it's also sometimes possible to get the correct denotation through an incorrect logical form (this will complicate things later on, when we learn from denotations alone). However, examining some instances will show that this baseline model has very poor performance on complex examples.

Note: some of the questions are yes/no questions (e.g. _is virginia east of west virginia_). If the denotation for a question is empty (`set()`), it should be interpreted as a "no" answer; if the denotation is non-empty (`{'virginia'}`) it should be interpreted as a yes. A different version of this dataset, introduced by [Andreas et al. 2016](https://arxiv.org/abs/1601.01705), adds an `any` operation to the logical forms for yes/no questions, which maps empty denotations to "no" and non-empty to "yes", but this makes training from denotations (which we'll do later on) more difficult.
"""

def make_greedy_prediction_function(model):
  # helper function to make a prediction function for evaluate_predictions for a model
  def prediction_function(instance):
    state, _ = greedy_search(model, instance)
    if state.parser_state.is_complete:
      return state.parser_state.to_logical_form()
    else:
      None
  return prediction_function

dummy_model = DummyModel(max_vars=4, no_repeated_literals=True)
evaluate_predictions(
  GeoDataset(DEV_STATES, word_to_embedding), 'dev', execute,
  prediction_function=make_greedy_prediction_function(dummy_model),
  display_predictions_frequency=5
)

"""Now we'll implement a neural model to train on the dataset. We've defined the encoder for you in the cell below, following one possible implementation for the encoder from project 2. The dataset is small enough that batching and using a GPU are unnecessary, so we will leave them out for simplicity."""

class Encoder(nn.Module):
  def __init__(self, hidden_dim, word_vector_dim, dropout):
    # word_vectors: vocab_size x dim
    super(Encoder, self).__init__()
    self.hidden_dim = hidden_dim
    self.word_vector_dim = word_vector_dim
    self.dropout = nn.Dropout(dropout)
    self.lstm = nn.LSTM(self.word_vector_dim, hidden_dim,
                        bidirectional=True, batch_first=True)

  def forward(self, embedded_sentence):
    # embedded_sentence: T x word_vector_dim
    lstm_out, (h_n, c_n) = self.lstm(embedded_sentence.unsqueeze(0))

    # eliminate batch dimension
    h_n = h_n.squeeze(0)
    c_n = c_n.squeeze(0)

    # n_layers x directions x T
    h_n = h_n.view(1, 2, -1).mean(1)
    c_n = c_n.view(1, 2, -1).mean(1)

    # eliminate batch dimension
    lstm_out = lstm_out.squeeze(0)
    return self.dropout(lstm_out), (h_n, c_n)

"""Before building the decoder, we'll define some helper functions to work with probability distributions over actions in log space."""

# helper functions to deal with probabilities in log space
def sum_log_probs(log_probs):
  # log_probs: List[tensor]
  # compute \log \sum_x \exp x
  return torch.logsumexp(torch.stack(
    list(log_probs), dim=-1
  ), -1)

def renormalize_log_prob_dict(log_prob_dict):
  # log_prob_dict: Dict[str, tensor]
  # rescale the log probs so that when exponentiated, they sum to 1
  if not log_prob_dict:
    return log_prob_dict
  Z = sum_log_probs(log_prob_dict.values())
  return {k: v - Z for k, v in log_prob_dict.items()}

def filter_log_prob_dict(log_prob_dict, valid_actions):
  return {
    k: v for k, v in log_prob_dict.items()
    if k in valid_actions
  }

def is_normalized(log_prob_dict):
  # log_prob_dict: Dict[str, tensor]
  # check that this dictionary is normalized in log space
  # e.g. as returned by renormalize_log_prob_dict
  if not log_prob_dict:
    return True
  return torch.allclose(
    sum_log_probs(log_prob_dict.values()).exp(),
    torch.tensor(1.0),
    atol=1e-3
  )

"""You'll now define part of the Decoder. You'll implement an attention-based pointer-generator model (based roughly on section 3.2 of [Jia and Liang 2016](https://arxiv.org/pdf/1606.03622.pdf) and section 2.2 of [See et al. 2017](https://arxiv.org/pdf/1704.04368.pdf)), which is useful for sequence-to-sequence tasks where parts of the output are copied from the input (in our case, predicates will be copied from the tokens they are associated with). 

Actions can be produced either through a `generate` action (given by predicting them from a standard projection layer, similar to the vocab prediction in the previous assignments) or a `copy` action: "pointing" to them in the set of predicates associated with each token in the question, using an attention mechanism. 

An action is produced by marginalizing over a binary choice to `copy` or `generate`, with $p(copy) = 1 - p(generate)$:

$p(action) = p(action | generate) * p(generate) + p(action | copy) * p(copy)$

`STRUCTURAL_ACTIONS` can only be produced by generating. `DATABASE_SPECIFIC_PREDICATE_ACTIONS` can only be produced by copying (since all of these will be unseen when evaluating on a new database). `CROSS_DATABASE_PREDICATE_ACTIONS` can be produced either by generating or copying.


You'll implement this in the `forward()` method of `Decoder`, computing $p(action)$ for each action in `actions_to_score` by combining the probabilities as above. Below are details about the generation mechanism (which we've implemented) and copy mechanism (which you'll implement).

__Generation mechanism__

$p(action | generate)$ is produced using a standard projection layer similar to the vocab prediction in the previous assignments, assigning scores to actions in `STRUCTURAL_ACTIONS` + `CROSS_DATABASE_PREDICATE_ACTIONS`. We've implemented this for you, in `_generate_log_probs()`.

__Copy mechanism__

Actions for predicates that are associated with words in the sentence can be produced by "pointing" to them with an attention mechanism. We will reuse the decoder's attention mechanism, masked and renormalized to only be over those tokens that have associated predicates, to give a distribution $p(position | copy)$. A given predicate can appear with multiple tokens, so marginalize over the positions in the sentence:

$p(action | copy) = \sum_{position} p(action | position, copy) p(position | copy)$

A given position can have zero, one, or multiple predicates associated with it (e.g. the token "ocean" can have both the `ocean` or the `kb-atlantic_ocean` predicates associated with it); produce a distribution over the predicates at each position using a softmax of the dot product between a `predicate_key` vector (a projection of the decoder state, which we've computed for you) and the pretrained embedding for the action's predicate:

$p(action | position, copy) = softmax(\texttt{predicate_embedding}^\top \texttt{predicate_key})$

You'll implement this in the `.copy_log_probs()` method in `Decoder` below.

Fill in the `._copy_log_probs()` and `.forward()` methods in the `Decoder` class below.

__Implementation tip__: Do probability calculations in log space: `p*q` can be computed using `+` when values are represented as log probabilities. In the same way, the `torch.logsumexp` function computes the sum `p+q` when `p` and `q` (and the returned value) are represented as log probabilities.
"""

class Decoder(nn.Module):
  START_ACTION = "<START>"
  DATABASE_SPECIFIC_ACTION = "<KB_ENTITY>"

  def __init__(self, hidden_dim, action_embedding_dim, input_action_vec_dim, dropout):
    super(Decoder, self).__init__()
    self.hidden_dim = hidden_dim
    self.action_embedding_dim = action_embedding_dim
    self.input_action_vec_dim = input_action_vec_dim

    self.action_index = Index()
    generable_indices = []
    for action in STRUCTURAL_ACTIONS:
      generable_indices.append(self.action_index.index(action))
    for action in CROSS_DATABASE_PREDICATE_ACTIONS:
      generable_indices.append(self.action_index.index(action))
    self.generable_indices = generable_indices
    self.START_INDEX = self.action_index.index(Decoder.START_ACTION)
    self.DATABASE_SPECIFIC_ACTION_INDEX = self.action_index.index(Decoder.DATABASE_SPECIFIC_ACTION)
    self.action_index.frozen = True

    self.action_embeddings = nn.Embedding(self.action_index.size(), self.action_embedding_dim)

    self.dropout = nn.Dropout(dropout)
    self.lstm_cell = nn.LSTMCell(self.action_embedding_dim, self.hidden_dim)

    self.action_scoring_layer = nn.Linear(hidden_dim, self.input_action_vec_dim)

    self.encoder_projection = nn.Linear(hidden_dim * 2, hidden_dim)
    self.copy_or_generate_layer = nn.Linear(hidden_dim, 2)
    self.generate_layer = nn.Linear(hidden_dim, len(generable_indices))

  def _pre_prediction(self, encoder_output, last_action, last_hidden):
    if last_action in self.action_index:
      action_index = self.action_index.index(last_action)
    elif last_action is None:
      action_index = self.START_INDEX
    else:
      action_index = self.DATABASE_SPECIFIC_ACTION_INDEX

    embedded_action = self.action_embeddings(torch.LongTensor([action_index]))
    h, c = self.lstm_cell(embedded_action, last_hidden)
    hidden_state = (h, c)
    decoder_out = h.squeeze(0)
    decoder_out = self.dropout(decoder_out)

    encoder_output_projected = self.encoder_projection(encoder_output)

    attention_logits = torch.einsum("th,h->t", [encoder_output_projected, decoder_out])
    attention_dist = torch.softmax(attention_logits, dim=-1)
    pooled_inputs = torch.einsum("th,t->h", [encoder_output_projected, attention_dist])

    output_with_attention = decoder_out + pooled_inputs

    return hidden_state, output_with_attention, attention_logits

  def _position_attention(self, predicates_at_each_word_position, attention_logits):
    positions_without_actions = [ix for ix, l in enumerate(predicates_at_each_word_position) if not l]
    position_attention_logits = attention_logits.clone()
    position_attention_logits[positions_without_actions] = BIG_NEG
    if len(positions_without_actions) == len(predicates_at_each_word_position):
      raise ValueError('no valid positions with predicates to copy to')
    return torch.log_softmax(position_attention_logits, dim=-1)

  def _generate_log_probs(self, actions_to_score, output_with_attention):
    # return log p(action | generate) for actions in actions_to_score,
    # as a dictionary mapping actions to torch scalars
    # log probabilities will be normalized over all generable actions; *NOT* over just actions_to_score
    # (renormalization will happen at the end of forward(), after all marginalizations are complete)
    logits = self.generate_layer(output_with_attention)
    log_probs = torch.log_softmax(logits, dim=-1)
    return {
      action: log_probs[self.action_index.index(action)]
      for action in actions_to_score
      if action in self.action_index
    }

  def _copy_log_probs(self,
                         predicate_key,
                         predicates_at_each_word_position,
                         embedded_predicates_at_each_word_position,
                         position_attention_log_probs,
                         copyable_actions):
    """

    :param predicate_key:
      tensor of size (embedded_predicate_dim,)
    :param predicates_at_each_word_position:
      List[List[str]], containing the list of predicates associated with each position in the sentence
    :param embedded_predicates_at_each_word_position:
      List[tensor], containing the predicate embeddings associated with each position in the sentence.
      embedded_predicates_at_each_word_position[i].size() == len(predicates_at_each_word_position[i]), embedding_dim
    :param position_attention_log_probs:
      tensor of size (len(sentence)), containing log p(position | copy)
    :param copyable_actions:
      Set[str], containing all predicates that can be copied to in this sentence
    :return:
      log p(action | copy) for actions in actions_to_score,
      as a dictionary mapping actions to torch scalars
      this dictionary should be normalized (in log space), over all copyable actions
      Implementation tip: you shouldn't have to normalize this yourself, it should happen
      by construction
    """

    """YOUR CODE HERE"""

    log_probs_actions_over_positions = [torch.log_softmax( torch.einsum("ij,j->i", [embedded_predicates, predicate_key]), dim=-1)
                                        if embedded_predicates.size(0) else None
                                        for embedded_predicates in embedded_predicates_at_each_word_position
                                       ]
    log_probs_actions = {}

    for action in copyable_actions:

      action_indices = [predicates.index(action) if action in predicates else -1
                        for predicates in predicates_at_each_word_position
                       ]
      log_probs_action_over_positions = [log_probs[i] if i != -1 else BIG_NEG
                                         for i, log_probs in zip(action_indices, log_probs_actions_over_positions)
                                        ]
      log_probs_action_over_positions = torch.tensor(log_probs_action_over_positions)
      log_probs_action_prod = log_probs_action_over_positions + position_attention_log_probs
      log_probs_actions[action] = torch.logsumexp(log_probs_action_prod, dim=-1)

    return log_probs_actions

  def forward(self,
              encoder_output,
              predicates_at_each_word_position,  # [[action, vector]]
              embedded_predicates_at_each_word_position,
              last_action,
              last_hidden_state,
              actions_to_score):
    """
    :return:
      * action_log_probs: a Dict[str, tensor], mapping each action in actions_to_score to a scalar tensor, giving the action's log probability
      * hidden_state: (h, c), decoder's updated hidden state after taking last_action
    """
    T, hidden_dim = encoder_output.size()

    # hidden_state: (h, c), each a tensor of size (hidden_dim,)
    # output_with_attention: tensor of size (hidden_dim,)
    # attention_logits: tensor of size (T,)
    hidden_state, output_with_attention, attention_logits = self._pre_prediction(
      encoder_output, last_action, last_hidden_state
    )

    all_predicates = set([p for ps in predicates_at_each_word_position for p in ps])
    #

    # copy_lp and generate_lp are each scalar tensors, giving log p(copy) and log p(generate)
    copy_lp, generate_lp = torch.log_softmax(self.copy_or_generate_layer(output_with_attention), dim=-1)

    # generate_action_log_probs. log p(action | generate), for generable actions in actions_to_score
    # a Dict[str, tensor], mapping each action in actions_to_score to a scalar tensor, giving the action's log probability
    generate_action_log_probs = self._generate_log_probs(actions_to_score, output_with_attention)

    # position_attention_log_probs: tensor of size (T,) giving log p(position | copy)
    position_attention_log_probs = self._position_attention(predicates_at_each_word_position, attention_logits)

    # compute log p(action | copy) for actions in all_predicates (the copyable actions)
    # a Dict[str, tensor], mapping each action in all_predicates to a scalar tensor, giving the action's log probability
    copy_action_log_probs = self._copy_log_probs(
      self.action_scoring_layer(output_with_attention),
      predicates_at_each_word_position,
      embedded_predicates_at_each_word_position,
      position_attention_log_probs,
      all_predicates
    )
    if copy_action_log_probs:
      assert is_normalized(copy_action_log_probs)

    # now, filter this down to only those actions we want to score
    copy_action_log_probs = filter_log_prob_dict(copy_action_log_probs, actions_to_score)

    # compute the probability of each action, p(action) as:
    # p(action) = p(action | generate) * p(generate) + p(action | copy) * p(copy)
    # p(position | copy) is given by position_attention_log_probs (a tensor)
    # p(action | generate) and p(action | copy) are given by generate_action_log_probs and copy_action_log_probs (dictionaries), above

    """YOUR CODE HERE"""

    action_log_probs = {}

    for action in actions_to_score:

      if action in STRUCTURAL_ACTIONS:
        action_log_probs[action] = generate_action_log_probs[action] + generate_lp
      elif action in DATABASE_SPECIFIC_PREDICATE_ACTIONS:
        action_log_probs[action] = copy_action_log_probs[action] + copy_lp

      elif action in CROSS_DATABASE_PREDICATE_ACTIONS:

        log_probs = [generate_action_log_probs[action] + generate_lp, copy_action_log_probs[action] + copy_lp]
        action_log_probs[action] = sum_log_probs(log_probs)

      else:
        assert 0 == 1, "Warning! Debug"

    assert all(a in action_log_probs for a in actions_to_score)
    # since this contains only a subset of actions, renormalize (in log-space)
    filtered = renormalize_log_prob_dict(
      filter_log_prob_dict(action_log_probs, valid_actions=actions_to_score)
    )
    for v in filtered.values():
      assert v > -1e8
    return filtered, hidden_state

"""The cell below defines a `Model` class using this `Encoder` and `Decoder`, with the same interface we used in `DummyModel`. We've hardcoded some hyperparameters for size and dropout that we found to work well."""

class Model(nn.Module):
  def __init__(self, max_vars=len(VARS), no_repeated_literals=True, max_literals=MAX_LITERALS):
    super(Model, self).__init__()
    self.max_vars = max_vars
    self.max_literals = max_literals
    self.no_repeated_literals = no_repeated_literals

    self.hidden_dim = 50
    self.action_embedding_dim = 50
    self.dropout = 0.2

    self.encoder = Encoder(self.hidden_dim, EMBEDDING_DIM, self.dropout)
    self.decoder = Decoder(self.hidden_dim, self.action_embedding_dim, EMBEDDING_DIM, self.dropout)
    self.max_vars = max_vars

  def initialize_model_state(self, instance):
    parse_constraints = ParseConstraints(
      possible_predicates=instance['possible_predicates'],
      max_vars=self.max_vars,
      no_repeated_literals=self.no_repeated_literals,
      max_literals=self.max_literals,
    )
    parser_state = ParserState.initial_state(parse_constraints)

    encoder_output, encoder_hidden = self.encoder(instance['embedded_words'])

    # define a decoder variable so that we can reference it inside the ModelState class without using self;
    decoder = self.decoder

    # embed this class so that we don't have to reencode the input every time we take an action
    class ModelState(_ModelState):
      @staticmethod
      def _create_from_hidden_and_action(last_hidden_state, last_action, parser_state: ParserState):
        possible_actions = parser_state.valid_actions()
        action_log_probs, hidden = decoder(
          encoder_output,
          instance['predicates_at_each_word_position'],
          instance['embedded_predicates_at_each_word_position'],
          last_action,
          last_hidden_state,
          actions_to_score=possible_actions
        )
        return ModelState(parser_state, hidden, action_log_probs)

      def take_action(self, action: str):
        parser_state = self.parser_state.take_action(action)
        return ModelState._create_from_hidden_and_action(self.hidden_state, action, parser_state)

    # the decoder expects None to start the action sequence
    last_action = None
    return ModelState._create_from_hidden_and_action(encoder_hidden, last_action, parser_state)

"""## Supervised Training

We'll first assume a supervised setting, where logical forms are provided for each question and used to directly supervise the model outputs. Later on, we'll relax this assumption and train from questions and denotations (answers) alone, using latent logical forms. In the two cells below, we've provided training code that will use the model and parser states you've defined.
"""

def make_beam_prediction_function(model, beam_size=5):
  # helper function to make a prediction function for evaluate_predictions for a model
  def prediction_function(instance):
    candidates = beam_search(model, instance, beam_size)
    if not candidates:
      return None
    state, _ = candidates[0]
    if state.parser_state.is_complete:
      return state.parser_state.to_logical_form()
    else:
      return None
  return prediction_function

def train(model, train_dataset, dev_dataset, model_file, num_epochs=10, latent_logical_forms=False,
          training_beam_size=None, learning_rate=1e-3, display_predictions_frequency=None):
  optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)
  stats_by_epoch = {}

  train_dataloader = DataLoader(train_dataset, shuffle=True, batch_size=1, collate_fn=lambda x: x)

  if latent_logical_forms:
    assert training_beam_size is not None

  if not latent_logical_forms:
    loss_function_for_eval = lambda instance: supervised_loss(model, instance).item()
  else:
    loss_function_for_eval = None

  prediction_function = make_beam_prediction_function(model, 5)

  best_metric = 0.0
  for epoch in tqdm.notebook.trange(num_epochs, desc="training", unit="epoch"):
    with tqdm.notebook.tqdm(
        train_dataloader,
        desc="epoch {}".format(epoch + 1),
        unit="instance",
        total=len(train_dataloader)
    ) as batch_iterator:
      model.train()

      total_num_correct_lfs = 0
      total_num_lfs = 0

      total_loss = 0.0

      for i, batch in enumerate(batch_iterator, start=1):
        assert len(batch) == 1
        instance = batch[0]

        optimizer.zero_grad()
        if latent_logical_forms:
          loss, num_correct_lfs, num_lfs = latent_loss(model, instance, training_beam_size)
          total_num_lfs += num_lfs
          total_num_correct_lfs += num_correct_lfs
          batch_iterator.set_postfix(
            train_correct_candidates_per_instance=total_num_correct_lfs/total_num_lfs*training_beam_size,
            train_loss=total_loss / i
          )
        else:
          loss = supervised_loss(model, instance)
        total_loss += loss.item()
        loss.backward()
        optimizer.step()
      model.eval()
      train_stats = evaluate_predictions(
        train_dataset, 'train', execute,
        prediction_function=prediction_function,
        loss_function=loss_function_for_eval,
        display_predictions_frequency=display_predictions_frequency
      )
      dev_stats = evaluate_predictions(
        dev_dataset, 'dev', execute,
        prediction_function=prediction_function,
        loss_function=loss_function_for_eval,
        display_predictions_frequency=display_predictions_frequency
      )
      dev_metric = dev_stats['dev_denotation_acc']
      batch_iterator.set_postfix({'train_loss': (total_loss / len(batch_iterator)), **train_stats, **dev_stats})
      if dev_metric > best_metric:
        best_epoch = epoch
        print("Obtained a new best development accuracy of {:.3f}, saving model "
              "checkpoint to {}...".format(dev_metric, model_file))
        torch.save(model.state_dict(), model_file)
        best_metric = dev_metric
      stats_by_epoch[epoch] = dev_stats
  print("Maximal development accuracy of {:.3f}".format(best_metric))
  print("Reloading best model checkpoint from {}...".format(model_file))
  model.load_state_dict(torch.load(model_file))

"""The supervised loss takes each action in the traversal of the correct logical form, collecting the log probabilities of these actions along the way."""

def supervised_loss(model, instance):
  state = model.initialize_model_state(instance)
  gold_actions = ParserState.from_logical_form(instance['logical_form']).actions()

  loss = torch.tensor(0.0)
  for action in gold_actions:
    loss += -1.0 * state.action_log_probs[action]
    state = state.take_action(action)

  return loss

train_dataset = GeoDataset(TRAIN_STATES, word_to_embedding)
dev_dataset = GeoDataset(DEV_STATES, word_to_embedding)
test_dataset = GeoDataset(TEST_STATES, word_to_embedding)

print('{} train instances'.format(len(train_dataset)))
print('{} dev instances'.format(len(dev_dataset)))
print('{} test instances'.format(len(test_dataset)))

supervised_model = Model()

"""We'll now train the model in the cell below. You should obtain a maximal denotation accuracy of at least 78% on the development set. This is a very small dataset and will have some variance. With our reference implementation we obtained 82-83% maximal dev denotation accuracy on average, with a range of 78% to 85% (over 40 trials)."""

train(supervised_model, train_dataset, dev_dataset, 'supervised_model.pt', num_epochs=10)

"""We'll now view the model predictions on the dev set."""

evaluate_predictions(
  dev_dataset, 'dev', execute,
  prediction_function=make_beam_prediction_function(supervised_model),
  display_predictions_frequency=5
)

"""## Training with Latent Logical Forms

Now, we will relax the assumption that we have logical forms available, and train our model only from question--answer pairs, the databases, and the execution function. This setting, _training from denotations_, requires less supervision but introduces problems of search, delayed reward, and ambiguity, as there are many possible logical forms that can execute to a given denotation. We'll use a classic method, _maximum marginal likelihood_; if you're interested in other methods, see [Misra et al. 2018](https://dipendramisra.com/papers/mchy-emnlp.2018.pdf) and [Guu et al. 2017](https://arxiv.org/abs/1704.07926) for a survey and connections to policy gradient from reinforcement learning.

Let $x$ be a question, $z$ be the denotation for the question, and $d$ be a database. Our model gives a distribution $p_\theta(y \mid x)$ for logical forms $y$.  Maximum marginal likelihood (approximately) maximizes the log probability of producing the correct denotation $z$, marginalized over logical forms. In practice, we can't sum over all possible logical forms, so we'll approximate using a set of logical forms $\mathcal{Y}$ returned by beam search:

$$J_{MML} = \log p(z \mid x, d) \approx \log \sum_{y \in \mathcal{Y}} p(z \mid y, d) p_\theta(y \mid x)$$

Our execution function (given by the `execute` function we've defined above) is deterministic, and we have $p(z \mid y, d) = 1$ or $0$ depending on whether $y$ denotes $z$ in the database. We can use this fact to simplify the objective: letting $\mathcal{C}$ be the subset of _correct_ logical forms $\mathcal{Y}$, that evaluate to $z$, we have

$$J_{MML} = \log \sum_{y \in \mathcal{C}} p_\theta(y \mid x)$$

Implement this in the `latent_loss` method below, returning $-J_{MML}$ as the loss, as well as the number of logical forms in $\mathcal{C}$ (`num_correct`) and the number of logical forms found by search (`num_instances`).

__Implementation tip__: for numerical stability, perform calculations in log space using the logical forms' log probabilities and `torch.logsumexp`.
"""

def latent_loss(model, instance, beam_size):
  true_denotation = instance['denotation']
  world = instance['world']

  # contains tuples of model states and total log probabilities returned by beam search: [(model_state: ModelState, log_prob: tensor)]
  # some model states may correspond to incomplete logical forms, as when repeated literals are not allowed, it's possible for the model to reach a state where no valid actions are available
  # use model_state.parser_state.is_complete to check whether a parser state corresponds to a complete logical form, before attempting to convert it to a logical form
  candidates = beam_search(model, instance, beam_size)

  num_correct = 0
  num_instances = len(candidates)

  """YOUR CODE HERE"""

  log_prob_lst = []

  for model_state, log_prob in candidates:

    if model_state.parser_state.is_complete:
      logical_form = model_state.parser_state.to_logical_form()
      executed_denotation = execute(logical_form, world)

      if executed_denotation == true_denotation:
        num_correct += 1
        log_prob_lst.append(log_prob)

  if num_correct == 0:
    # no update if no correct examples were found; define a Variable to not break the backprop and update code
    return torch.autograd.Variable(torch.tensor(0.0), requires_grad=True), num_correct, num_instances
  else:
    loss = -sum_log_probs(log_prob_lst)
    return loss, num_correct, num_instances

"""You can sanity check your loss by training and evaluating on a restricted version of the dataset which contains only logical forms with at most two variables and two literals. These examples will be a bit easier, and the constrains on logical forms will allow us to reduce the search space and train faster."""

def is_complex_lf(logical_form):
  if len(ParserState.from_logical_form(logical_form).variables_introduced()) > 2:
    return True
  if ParserState.from_logical_form(logical_form).completed_literal_stack.size > 2:
    return True
  return False

simple_train_dataset = GeoDataset(TRAIN_STATES, word_to_embedding, logical_form_exclude_function=is_complex_lf)
simple_dev_dataset = GeoDataset(DEV_STATES, word_to_embedding, logical_form_exclude_function=is_complex_lf)
print('{} train instances with maximum 2 variables and 2 literals'.format(len(simple_train_dataset)))
print('{} dev instances with maximum 2 variables and 2 literals'.format(len(simple_dev_dataset)))
print()
for i in range(3):
  print_instance(simple_dev_dataset[i])
  print()

simple_latent_model = Model(max_vars=2, max_literals=2)

"""The following cell will train your model from denotations alone on these simplified logical forms. 

With beam size 100, if your `latent_loss` implementation is correct, you should expect to see `train_loss` values roughly between 0.5 and 2 at the end of 10 epochs (note that the magnitude of the loss will change with varying number of candidates).

Our implementation obtains _training_ denotation accuracies between 80% and 100%, and dev denotation accuracies of at least 60% by the end of 10 epochs (but note there are only 9 dev examples when filtering the logical forms in this way! so don't be surprised if this score varies widely).
"""

train(simple_latent_model, simple_train_dataset, simple_dev_dataset, 'simple_latent_model.pt', 
      num_epochs=10, latent_logical_forms=True, 
      training_beam_size=100)

evaluate_predictions(
  simple_dev_dataset, 'dev', execute,
  prediction_function=make_beam_prediction_function(simple_latent_model),
  display_predictions_frequency=1
)

"""Now, we'll proceed to training on the full dataset with an unrestricted model. The search space is larger here and it may take several epochs before performance starts to increase. While the training loss should consistently decrease, you may see fluctuations in denotation accuracy (both on train and dev) from epoch to epoch. However, you'll likely obtain training denotation accuracies >80% and dev denotation accuracies >70% at some point by epoch 5. Your maximal dev accuracy should be at least 63%, although there is again some variance due to the small dataset size, which is compounded by the variance from training from denotations. Our reference implementation obtained an average maximal dev accuracy of 80%, but ranged between 63% and 90% (over 40 trials). 10 epochs of training should take around 20-30 minutes."""

latent_model = Model()

train(latent_model, train_dataset, dev_dataset, 'latent_model.pt', 
      num_epochs=10, latent_logical_forms=True, 
      training_beam_size=100)

"""You can run the following cell to see the model predictions:"""

evaluate_predictions(
  dev_dataset, 'dev', execute,
  prediction_function=make_beam_prediction_function(latent_model),
  display_predictions_frequency=5
)

"""## Submission"""

def dump_logical_form_actions(dataset, fname):
  with open(fname, 'w') as f:
    for i in range(len(dataset)):
      parser_state = ParserState.from_logical_form(dataset[i]['logical_form'])
      f.write('{}\n'.format(' '.join(parser_state.actions())))

# to test your ParserState.take_action() method, we'll also save 
# the actions for the true logical forms
dump_logical_form_actions(dev_dataset, './dev_true_lf_actions.txt')
dump_logical_form_actions(test_dataset, './test_true_lf_actions.txt')

# Uncomment this code to restore models from a checkpoint.
#
# supervised_model = Model(max_vars=4, no_repeated_literals=True)
# supervised_model.load_state_dict(torch.load('supervised_model.pt'))
# latent_model = Model(max_vars=4, no_repeated_literals=True)
# latent_model.load_state_dict(torch.load('latent_model.pt'))

pprint.pprint(evaluate_predictions(
  dev_dataset, 'supervised_dev', execute,
  prediction_function=make_beam_prediction_function(supervised_model, 5),
  logical_form_output_file='./supervised_dev_lfs.txt'
))
pprint.pprint(evaluate_predictions(
  test_dataset, 'supervised_test', execute,
  prediction_function=make_beam_prediction_function(supervised_model, 5),
  logical_form_output_file='./supervised_test_lfs.txt'
))
pprint.pprint(evaluate_predictions(
  dev_dataset, 'latent_dev', execute,
  prediction_function=make_beam_prediction_function(latent_model, 5),
  logical_form_output_file='./latent_dev_lfs.txt'
))
pprint.pprint(evaluate_predictions(
  test_dataset, 'latent_test', execute,
  prediction_function=make_beam_prediction_function(latent_model, 5),
  logical_form_output_file='./latent_test_lfs.txt'
))

"""Your submission should consist of your code, the actions to generate true logical forms for the dev and test set (to test your ParserState.take_action() method), as well as the logical forms predicted by your model for both dev and test data in supervised and latent settings. Turn in the following files on Gradescope:

- proj_4.ipynb (this file; please rename to match)
- dev_true_lf_actions.txt
- test_true_lf_actions.txt
- supervised_dev_lfs.txt
- supervised_test_lfs.txt
- latent_dev_lfs.txt
- latent_test_lfs.txt

Be sure to check the output of the autograder after it runs. It should confirm that no files are missing and that the output files have the correct format.
"""